<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <title>Python profiling - Thavanathan</title>
  <meta property="og:title" content="Python profiling - Thavanathan" />
  <meta name="twitter:title" content="Python profiling - Thavanathan" />
  <meta name="description" content="There are three main modules that provides time benchmarking in python.
 timeit - call it for profiling small python statements. (check out timeit module) cProfile - c extension for profiling. Profile - pure python implementation of cProfile. It exposes the same functions and classes of cProfile.  code:
:::python import cProfile from collections import deque p = cProfile.Profile() # create a new profile object d = deque() li = [] p.">
  <meta property="og:description" content="There are three main modules that provides time benchmarking in python.
 timeit - call it for profiling small python statements. (check out timeit module) cProfile - c extension for profiling. Profile - pure python implementation of cProfile. It exposes the same functions and classes of cProfile.  code:
:::python import cProfile from collections import deque p = cProfile.Profile() # create a new profile object d = deque() li = [] p.">
  <meta name="twitter:description" content="There are three main modules that provides time benchmarking in python.
 timeit - call it for profiling small python statements. (check out timeit module) cProfile - c extension for profiling. Profile â€¦">
  <meta name="author" content=""/>
  <meta property="og:site_name" content="Thavanathan" />
  <meta property="og:url" content="http://example.org/posts/2013-08-28-python-profiling/" />
  <meta property="og:type" content="article" />
  <meta name="twitter:card" content="summary" />
  <meta name="generator" content="Hugo 0.64.1" />

  <link rel="stylesheet" href="/css/style.css" media="all" />
  <link rel="stylesheet" href="/css/syntax.css" media="all" />
  <link rel="stylesheet" href="/css/custom.css" media="all" />

  <script src="/js/script.js"></script>
  <script src="/js/custom.js"></script>
  <script defer src="/js/fontawesome.js"></script>
</head>

<body>

<header class="site-header">
  <nav class="site-navi">
    <h1 class="site-title"><a href="/">Thavanathan</a></h1>
    <ul class="site-navi-items">
      <li class="site-navi-item-"><a href="/" title="Home">Home</a></li>
      <li class="site-navi-item-"><a href="/posts/" title="Posts">Posts</a></li>
      <li class="site-navi-item-"><a href="/pages/tutorials/" title="Tutorials">Tutorials</a></li>
      <li class="site-navi-item-"><a href="/about/" title="About">About</a></li>
    </ul>
  </nav>
</header>
<hr class="site-header-bottom">

  <div class="main" role="main">
    <article class="article">
      
      
      <h1 class="article-title">Python profiling</h1>
      
      <hr class="article-title-bottom">
      <ul class="article-meta">
        <li class="article-meta-date"><time>August 28, 2013</time></li>
        <li class="article-meta-categories">
          <a href="/categories/python/">
            <i class="fas fa-folder"></i>
            Python
          </a>&nbsp;
        </li>
      </ul>
      
      <p>There are three main modules that provides time benchmarking in python.</p>
<ol>
<li>timeit - call it for profiling small python statements. (check out timeit module)</li>
<li>cProfile - c extension for profiling.</li>
<li>Profile - pure python implementation of cProfile. It exposes the same functions and classes of cProfile.</li>
</ol>
<p>code:</p>
<pre><code>:::python

import cProfile
from collections import deque
p = cProfile.Profile() # create a new profile object
d = deque()
li = []
p.enable() # start profiling.
for i in range(100000): # 100000 iterations for much accurate results.
   li.insert(0, 100)
p.disable() # stop profiling.
p.print_stats()

p = cProfile.Profile() # for profiling deque
p.enable()
for i in range(100000):
   d.appendleft(100)
p.disable()
p.print_stats()


:::bash
100002 function calls in 3.483 seconds

Ordered by: standard name

ncalls  tottime  percall  cumtime  percall filename:lineno(function)
    1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
100000    3.481    0.000    3.481    0.000 {method 'insert' of 'list' objects}
    1    0.001    0.001    0.001    0.001 {range}


     100002 function calls in 0.037 seconds

Ordered by: standard name

ncalls  tottime  percall  cumtime  percall filename:lineno(function)
100000    0.037    0.000    0.037    0.000 {method 'appendleft' of 'collections.deque' objects}
    1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
    1    0.001    0.001    0.001    0.001 {range}
</code></pre>
<p>The results are mostly self explanatory. First line is number of function calls made and time taken for that. Remaining lines are individual call results. List insertion almost takes 100 times more time than deque.
Time complexity for inserting a element at at the end of list or queue is O(1), so if we use li.append for list and deque.append for for deque, the benchmarking results will be almost same.</p>

    </article>

    


    <ul class="pager article-pager">
      <li class="pager-newer">
          <a href="/posts/2014-04-29-an-android-app/" data-toggle="tooltip" data-placement="top" title="An Android app to search baby names">&lt; Newer</a>
      </li>
      <li class="pager-older pager-noitem">Older &gt;</li>
    </ul>
  </div>


<div class="site-footer">
  <div class="copyright"></div>
  <ul class="site-footer-items">
  </ul>
  <div class="powerdby">
    Powered by <a href="https://gohugo.io/">Hugo</a> and <a href="https://github.com/taikii/whiteplain">Whiteplain</a>
  </div>
</div>


</body>
</html>
